package org.michaeldadams.gradle

import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.artifacts.ExternalDependency
import org.gradle.api.tasks.SourceSet
import org.gradle.api.provider.Property
import org.gradle.api.provider.MapProperty
import org.jetbrains.kotlin.gradle.dsl.KotlinJvmProjectExtension
import java.text.SimpleDateFormat
import java.util.Date

abstract class GenerateBuildInformationExtension() {
  abstract val packageName: Property<String>
  abstract val url: Property<String>
  // TODO: abstract val fields: MapProperty<String, Any?> = TODO()
  // systemPropertiesFilter/systemPropertiesList
  // RegularFileProperty
  // DirectoryProperty
}

class GenerateBuildInformationPlugin : Plugin<Project> {
  override fun apply(project: Project) {
    val name = "generateBuildInformation"
    val kotlin = project.extensions.getByType(KotlinJvmProjectExtension::class.java)
    val extension = project.extensions.create(name, GenerateBuildInformationExtension::class.java)
    val task = project.tasks.register(name) {
      description = "Create a BuildInformation class containing information about the build and build-time environment."
      group = "Build"
      doLast {
        fun String.escape() = """([\\\"\$])""".toRegex().replace(this, """\\$1""")

        val dependencies = project.configurations
          .flatMap { it.dependencies }
          .filterIsInstance<ExternalDependency>()
          .map {
            val key = "${it.group?.escape()}:${it.name.escape()}:${it.version?.escape()}"
            val value = "${it.targetConfiguration?.escape() ?: "default"}"
            "    \"${key}\" to \"${value}\","
          }.sorted()
          .joinToString("\n")

        val systemProperties = System.getProperties().toList()
          .filter { it.first.toString().matches("(java|os)\\..*".toRegex()) } // TODO: why filter?
          .map { "    \"${it.first?.toString()?.escape()}\" to \"${it.second?.toString()?.escape()}\"," }
          .sorted()
          .joinToString("\n")

        fun field(fieldName: String, value: Any?): String =
          "  val ${fieldName.trim()}: String? = ${value?.let { "\"${it.toString().escape()}\"" } ?: "null"}"

        val code = """
          |// Do not edit this file by hand.  It is generated by `gradle`.
          |${extension.packageName.getOrNull()?.let { "package ${it}\n" } ?: ""}
          |import javax.annotation.processing.Generated
          |
          |/** Information about the build and build-time environment */
          |@Generated("org.michaeldadams.gradle.GenerateBuildInformationPlugin")
          |object BuildInformation {
          |${field("group         ", project.group)}
          |${field("name          ", project.name)}
          |${field("version       ", project.version)}
          |${field("description   ", project.description)}
          |${field("kotlinVersion ", kotlin.coreLibrariesVersion)}
          |${field("kotlinPlatform", kotlin.target.platformType)}
          |${field("javaVersion   ", System.getProperty("java.version"))}
          |${field("gradleVersion ", project.gradle.gradleVersion)}
          |${field("buildTime     ", SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss.SSSXXX").format(Date()))}
          |${field("status        ", project.status)}
          |${field("path          ", project.path)}
          |
          |  /** Build-time dependencies and their target configurations */
          |  val dependencies: List<Pair<String, String>> = listOf(
          |$dependencies
          |  )
          |
          |  /** Build-time system properties and their values */
          |  val systemProperties: List<Pair<String, String>> = listOf(
          |$systemProperties
          |  )
          |
          |  val versionMessage = "${'$'}{name} version ${'$'}{version}${extension.url.getOrNull()?.let { " (${it})" } ?: "" }"
          |}
          |
        """.trimMargin()

        project.generateSrc("BuildInformation.kt", code) // TODO: include package in file name
      }
    }

    // Ensure that generateBuildInformation is called before compilation
    kotlin.sourceSets.getByName(SourceSet.MAIN_SOURCE_SET_NAME).kotlin.srcDir(task)
  }
}

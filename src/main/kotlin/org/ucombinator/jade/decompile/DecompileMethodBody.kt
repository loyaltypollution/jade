package org.ucombinator.jade.decompile

import com.github.javaparser.ast.Modifier
import com.github.javaparser.ast.NodeList
import com.github.javaparser.ast.body.BodyDeclaration
import com.github.javaparser.ast.body.ConstructorDeclaration
import com.github.javaparser.ast.body.InitializerDeclaration
import com.github.javaparser.ast.body.MethodDeclaration
import com.github.javaparser.ast.comments.BlockComment
import com.github.javaparser.ast.expr.ObjectCreationExpr
import com.github.javaparser.ast.expr.StringLiteralExpr
import com.github.javaparser.ast.stmt.BlockStmt
import com.github.javaparser.ast.stmt.EmptyStmt
import com.github.javaparser.ast.stmt.Statement
import com.github.javaparser.ast.stmt.ThrowStmt
import org.objectweb.asm.tree.ClassNode
import org.objectweb.asm.tree.MethodNode
import org.objectweb.asm.Opcodes
import org.objectweb.asm.util.Textifier
import org.objectweb.asm.util.TraceMethodVisitor
import org.ucombinator.jade.analysis.ControlFlowGraph
import org.ucombinator.jade.analysis.StaticSingleAssignment
import org.ucombinator.jade.asm.Insn
import org.ucombinator.jade.classfile.ClassName
import org.ucombinator.jade.javaparser.JavaParser
import org.ucombinator.jade.jgrapht.Dominator
import org.ucombinator.jade.jgrapht.GraphViz
import org.ucombinator.jade.util.Errors
import org.ucombinator.jade.util.Log
import java.io.PrintWriter
import java.io.StringWriter

/** Handles decompiling method bodies within classes. */
object DecompileMethodBody {
  private val log = Log {}

  /**
   * Returns a stub JavaParser BlockStmt with the given BlockComment and a throw statement with the given message. If either parameter is null, the given BlockStmt won't contain them.
   *
   * @param message the message of the throw statement in the returned BlockStmt
   * @param comment the BlockComment to be included
   * @return the stub JavaParser BlockStmt
   */
  private fun stubBody(message: String?, comment: BlockComment?): BlockStmt {
    val statements = NodeList<Statement>(
      if (message == null) {
          JavaParser.setComment(
              EmptyStmt(),
              comment
          )
      } else {
          JavaParser.setComment(
              ThrowStmt(
                  ObjectCreationExpr(
                      null,
                      ClassName.classNameType("java/lang/UnsupportedOperationException"),
                      NodeList(StringLiteralExpr(message))
                  )
              ),
              comment
              )
          }
      )

    if (false) { // TODO: option for generating compilable versus uncompilable stub bodies
      statements.add(
        JavaParser.setComment(
          EmptyStmt(),
          BlockComment(" The following is unreachable code so that this code generates a compilation error "),
        ),
      )
    }
    return BlockStmt(statements)
  }

    /**
    * Checks if the given MethodNode represents an abstract method.
    *
    * A method is considered abstract if it has no instructions and is marked with the `ACC_ABSTRACT` flag.
    *
    * @param node The MethodNode to check.
    * @return `true` if the method is abstract (no instructions and has `ACC_ABSTRACT` access flag), `false` otherwise.
    */
  fun isAbstract(node: MethodNode): Boolean = ((node.access and Opcodes.ACC_ABSTRACT) != 0).also {
    assert(it == (node.instructions.size() == 0))
  }

  /**
   * Returns a BlockStmt that contains the decompiled method's skeleton. Instructions within the
   * method are encoded as a string comment for later further decompilation. If the given MethodNode
   * is abstract i.e. has no body, null is returned.
   *
   * @param node a MethodNode
   * @return the desired BlockStmt object.
   */
  fun decompileBodyStub(node: MethodNode): BlockStmt? =
    if (isAbstract(node)) {
      null
    } else {
      val textifier = Textifier()
      node.accept(TraceMethodVisitor(null, textifier))
      val stringWriter = StringWriter()
      textifier.print(PrintWriter(stringWriter))
      val instructions = stringWriter.toString() 
      val stubComment = BlockComment(
          """
            | This is a stub implementation generated by the Jade decompiler.
            |         *
            |         * Max Stack: ${node.maxStack}
            |         * Max Locals: ${node.maxLocals}
            |         * Instructions:
            |${instructions.lines().map { "         *$it" }.joinToString("\n")}
            |
          """.trimMargin(),
        )

        if (node.name == "<clinit>") {
          /*
            For static block initialization, don't include a throw statement in the stub body. Doing so results in "error: initializer must be able to complete normally" as in the following example:
              static {
                throw new RuntimeException("");
              }
          */
          stubBody(null, stubComment)
        } else {
          stubBody("Jade decompiler generated only a stub implementation", stubComment)
        }
    }

  /** TODO:doc.
   *
   * @param declaration TODO:doc
   * @param body TODO:doc
   * @return TODO:doc
   */
  fun setDeclarationBody(declaration: BodyDeclaration<out BodyDeclaration<*>>, body: BlockStmt) {
    when (declaration) {
      is InitializerDeclaration -> declaration.setBody(body)
      is ConstructorDeclaration -> declaration.setBody(body)
      is MethodDeclaration -> declaration.setBody(body)
      else -> Errors.unmatchedType(declaration)
    }
  }

  /** TODO:doc.
   *
   * @param classNode TODO:doc
   * @param method TODO:doc
   * @param declaration TODO:doc
   * @return TODO:doc
   */
  fun decompileBody(classNode: ClassNode, method: MethodNode, declaration: BodyDeclaration<out BodyDeclaration<*>>) {
    if (method.instructions.size() == 0) {
      // The method has no body as even methods with empty bodies have a `return` instruction
      log.debug { "**** Method is has no body ****" }

      fun warningBody(warning: String): BlockStmt =
        if (false) { // TODO: option for fatal error vs uncompilable body vs compilable body
          log.error { warning }
          Errors.fatal(warning) // TODO
        } else {
          log.warn { warning }
          stubBody(warning, null)
        }

      when (declaration) { // TODO: use setDeclarationBody
        is InitializerDeclaration ->
          declaration.setBody(warningBody("No implementation for the static initializer for class ${classNode.name}"))
        is ConstructorDeclaration ->
          declaration.setBody(
            warningBody(
              "No implementation for constructor ${classNode.name}" +
                "(signature = ${method.signature}, descriptor = ${method.desc})",
            ),
          )
        is MethodDeclaration -> {
          val modifiers = declaration.modifiers
          // TODO: if !(*.sym)
          if (modifiers.contains(Modifier.abstractModifier()) || modifiers.contains(Modifier.nativeModifier())) {
            declaration.setBody(null)
          } else {
            declaration.setBody(
              warningBody(
                "No implementation for non-abstract, non-native method: ${classNode.name}.${method.name}" +
                  "(signature = ${method.signature}, descriptor = ${method.desc})",
              ),
            )
          }
        }
        else -> Errors.unmatchedType(declaration)
      }
    } else {
      log.debug { "**** Method has a body with ${method.instructions.size()} instructions ****" }
      log.debug { "**** ControlFlowGraph ****" }

      // loop via dominators (exit vs return is unclear)
      // if
      // switch via dominators
      // catch via dominators
      // synchronized: via CFG (problem: try{sync{try}}?)

      val cfg = ControlFlowGraph.make(classNode.name, method)

      log.debug { "++++ cfg ++++\n${GraphViz.toString(cfg)}" }
      for (v in cfg.graph.vertexSet()) {
        log.debug { "v: ${cfg.graph.incomingEdgesOf(v).size}: $v" }
      }

      log.debug { "**** SSA ****" }
      val ssa = StaticSingleAssignment.make(classNode.name, method, cfg)

      log.debug { "++++ frames: ${ssa.frames.size} ++++" }
      for (i in 0 until method.instructions.size()) {
        log.debug { "frame($i): ${ssa.frames[i]}" }
      }

      log.debug { "++++ results and arguments ++++" }
      for (i in 0 until method.instructions.size()) {
        val insn = method.instructions[i]
        log.debug { "args($i): ${Insn.longString(method, insn)} --- ${ssa.insnVars[insn]}" }
      }

      log.debug { "++++ ssa map ++++" }
      for ((key, value) in ssa.phiInputs) {
        log.debug { "ssa: $key -> $value" }
      }

      log.debug { "**** Dominators ****" }
      val doms = Dominator.dominatorTree(cfg.graphWithExceptions, cfg.entry)

      log.debug { "++++ dominator tree ++++\n${GraphViz.toString(doms)}" }

      log.debug { "++++ dominator nesting ++++\n${GraphViz.nestingTree(cfg.graphWithExceptions, doms, cfg.entry)}" }

      // log.debug { "**** Structure ****" }
      // val structure = Structure.make(cfg)

      // TODO: JEP 334: JVM Constants API: https://openjdk.java.net/jeps/334

      // log.debug { "**** Statement ****" }
      // val statement = DecompileStatement.make(cfg, ssa, structure)
      // log.debug { statement }
      // setDeclarationBody(declaration, statement)

      // var statements = List[Statement]()
      // for (insn in method.instructions.toArray) {
      //   val (retVal, decompiled) = DecompileInsn.decompileInsn(insn, ssa)
      //   statements = statements :+ DecompileInsn.decompileInsn(retVal, decompiled)
      // }
      // log.debug { "++++ statements ++++\n" + statements.mkString("\n") }
      // setDeclarationBody(declaration, new BlockStmt(new NodeList[Statement](statements.asJava)))
    }
  }
}

package org.ucombinator.jade.jgrapht

import org.jgrapht.Graph
import org.jgrapht.alg.lca.EulerTourRMQLCAFinder
import org.jgrapht.graph.SimpleDirectedGraph
import org.ucombinator.jade.util.Errors

object DominatorReference {

  fun <V, E> dominatorTree(graph: Graph<V, E>, root: V): DominatorTree<V> {
    val n = graph.vertexSet().size

    // The original algorithm dealt in Ints, not Vs, so we convert them using these maps.
    val vertexOfInt = MutableList<V?>(n + 1) { null }
    val intOfVertex = mutableMapOf<V, Int>()
    for ((i, v) in graph.vertexSet().withIndex()) {
      // Note that i is zero indexed and `dominators()` wants one indexed
      vertexOfInt[i + 1] = v
      intOfVertex[v] = i + 1
    }

    val succ = Array<Set<Int>>(n + 1) { src ->
      if (src == 0) { emptySet() } // unused
      else { graph.outgoingEdgesOf(vertexOfInt[src]!!).map { intOfVertex[graph.getEdgeTarget(it)]!! }.toSet() }
    }
    val dom = Array<Int>(n + 1) { -1 }

    dominators(succ, intOfVertex[root]!!, n, dom)

    // Translate to the expected result format.
    val tree = SimpleDirectedGraph<V, Dominator.Edge<V>>(Dominator.Edge::class.java as Class<Dominator.Edge<V>>)
    for ((v, _) in intOfVertex) { tree.addVertex(v) }
    for ((i, d) in dom.withIndex()) {
      if (d != -1 && vertexOfInt[d] != null) {
        tree.addEdge(vertexOfInt[i], vertexOfInt[d], Dominator.Edge<V>(vertexOfInt[i]!!, vertexOfInt[d]!!))
      }
    }

    return tree
  }

  /** Implements the Lengauer-Tarjan algorithm for computing graph dominators.
   *
   * This implementation is a literal transcription the algorithm from Appendix B of the paper:
   *
   *   Thomas Lengauer and Robert Endre Tarjan. A Fast Algorithm for Finding Dominators in a Flowgraph.
   *   ACM Transactions on Programming Languages and Systems, Vol. 1, No. 1, July 1979, Pages 121-141.
   *   https://doi.org/10.1145/357062.357071
   *
   * Consistent with that paper, this algorithm assumes the vertex set is V = { v | 1 <= v <= n },
   * and all arrays are one indexed, where array index zero and vertex zero are used as dummy
   * values.
   *
   * Note that since bytecode methods have only 2^16 bytes, Int is large enough to number all of
   * them including meta-instructions.
   *
   * @param succ The successors of each vertex
   * @param r The root vertex
   * @param n The number of vertexes
   * @param dom The output containing the immediate dominator of each vertex
   */
  fun dominators(succ: Array<Set<Int>>, r: Int, n: Int, dom: Array<Int>) {
    // There are three types relating to vertex that are all represented by integers.
    // - Vertexes represented by integers from 1 to n.
    // - Vertexes represented by integers from 0 to n, where 0 serves as a null or dummy value.
    // - Vertex numbers (as they are called in the paper) represnted by integers from 1 to n that
    //   are assigned by the depth-first search (DFS).  This name is confusing so we instead call
    //   them depth-first numbers (DFNum).
    //
    // TODO: see other impl for which Int are vertex or dfnum
    // Unless otherwise stated all arrays are one indexed and vertexes are non-zero.
    // TODO: n is a size

    // dom(w): Maps vertexes to the vertex that is their immediate dominator.
    // - After step 3:
    //   - The immediate dominator of w if the semidominator is its immediate dominator.
    //   - Otherwise a vertex with DFNum smaller than w and whose immediate dominator is also w's immediate dominator.
    // - After step 4: The immediate dominator of w.

    var n = n // make `n` mutable like in the paper

    val parent = Array<Int>(n + 1) { -1 } // The parent in the spanning tree generated by dfs().  Unchanged after dfs().
    val ancestor = Array<Int>(n + 1) { -1 } // The ancestor forest defined by link and used by eval.  Mutable and path compressed.  0 means no ancestor.
    val child = Array<Int>(n + 1) { -1 } /*V:1..n*/ // used by sophisticated link
    val vertex = Array<Int>(n + 1) { -1 } // The vertex assigned to a DFNum by dfs().  Never changes after dfs().
    val label = Array<Int>(n + 1) { -1 } /*0..n*/
    // semi(w): Maps vertexes to DFNums.
    // - Before vertex w is numbered, semi(v) = O.
    // - After w is numbered but before its semidominator is computed, semi(w) is the number of w.
    // - After the semidominator of w is computed, semi(w) is the number of the semidominator of w.
    val semi = Array<Int>(n + 1) { -1 } /*0..n*/ // Maps Vertex to DFNum.  0 maps to zero.  Zero if not visited by DFS.
    val size = Array<Int>(n + 1) { -1 } /*0..n*/ // used by sophisticated link
    val pred = Array<Set<Int>>(n + 1) { emptySet() } // The set of vertices v such that (v, w) is an edge of the graph.
    val bucket = Array<Set<Int>>(n + 1) { emptySet() } // A set of vertices whose semidominator is a given vertex.
    var u: Int
    // var v = 0 // replaced with `for`-loop bindings
    // var x = 0 // unused in paper

    // Depth-first search (DFS)
    fun dfs(v: Int) {
      n = n + 1
      semi[v] = n
      label[v] = v
      vertex[n] = v
      child[v] = 0
      ancestor[v] = 0
      size[v] = 1
      for (w in succ[v]) {
        if (semi[w] == 0) { parent[w] = v; dfs(w) } // for vertexes not yet visited by DFS
        pred[w] += v
      }
    }

    fun compress(v: Int) {
      if (ancestor[ancestor[v]] != 0) {
        compress(ancestor[v])
        if (semi[label[ancestor[v]]] < semi[label[v]]) {
          label[v] = label[ancestor[v]]
        }
        ancestor[v] = ancestor[ancestor[v]]
      }
    }

    // There are two implementations of eval and link: simple and sophisticated.
    // We define both and select between them by changing the defintion of eval() and link().

    // If v is the root of a tree in the ancestor forest, return v. Otherwise, let r be the root of
    // the tree in the forest which contains v. Return any vertex u != r of minimum semi(u) on the
    // path r -> v.
    fun evalSimple(v: Int) =
      if (ancestor[v] == 0) { v }
      else { compress(v); label[v] }
    fun evalSophisticated(v: Int) =
      if (ancestor[v] == 0) { label[v] }
      else { compress(v); if (semi[label[ancestor[v]]] >= semi[label[v]]) { label[v] } else { label[ancestor[v]] } }

    // Add edge (v, w) to the ancestor forest.
    fun linkSimple(v: Int, w: Int) {
      ancestor[w] = v
    }
    fun linkSophisticated(v: Int, w: Int) {
      var s: Int = w
      while (semi[label[w]] < semi[label[child[s]]]) {
        if (size[s] + size[child[child[s]]] >= 2 * size[child[s]]) {
          ancestor[child[s]] = s
          child[s] = child[child[s]]
        } else {
          size[child[s]] = size[s]
          ancestor[s] = child[s]
          s = child[s]
        }
      }
      label[s] = label[w]
      size[v] = size[v] + size[w]
      if (size[v] < 2 * size[w]) { s = child[v].also { child[v] = s } /* swap s and child[v] */ }
      while (s != 0) { ancestor[s] = v; s = child[s] }
    }

    // fun eval(v: Int) = evalSimple(v)
    // fun link(v: Int, w: Int) = linkSimple(v, w)
    fun eval(v: Int) = evalSophisticated(v)
    fun link(v: Int, w: Int) = linkSophisticated(v, w)

    // Step 1: Setup DFS spanning tree.  Number the vertices from 1 to n as they are reached during
    // the search.  Initialize the variables used in succeeding steps.
    for (v in 1..n) {
      bucket[v] = emptySet()
      pred[v] = emptySet()
      semi[v] = 0
    }
    n = 0
    dfs(r)
    semi[0] = 0
    label[0] = 0
    size[0] = 0

    // Iterate over nodes from bottom of DFS tree to top.
    for (i in n downTo 2) { // Do not include 1 because that DFNum is the root
      val w = vertex[i] // Convert DFNum to vertex

      // Step 2: Compute the semidominators of all vertices by applying Theorem 4. Carry out the
      // computation vertex by vertex in decreasing order by number.
      for (v in pred[w]) {
        u = eval(v)
        // Determine if pred is an ancestor in DFS tree.
        if (semi[u] < semi[w]) { semi[w] = semi[u] }
      }
      bucket[vertex[semi[w]]] += w
      link(parent[w], w)

      // step 3
      // For each bucket, find ancestor with lowest semi. If it has the same
      // semi, that semi is the idom. If not, it has the same semidominator.
      // Implicitly define the immediate dominator of each vertex by applying Corollary 1:
      for (v in bucket[parent[w]].toList()) { // toList() avoids concurrent modification exception
        bucket[parent[w]] -= v
        u = eval(v)
        dom[v] = if (semi[u] < semi[v]) { u } else { parent[w] }
      }
    }

    // Step 4: Explicitly define the immediate dominator of each vertex, carrying out the
    // computation vertex by vertex in increasing order by DFNum.
    for (i in 2..n) { // Do not include 1 because that DFNum is the root and never has a dominator.
      val w = vertex[i]
      if (dom[w] != vertex[semi[w]]) {
        dom[w] = dom[dom[w]]
      }
    }
    dom[r] = 0
  }
}

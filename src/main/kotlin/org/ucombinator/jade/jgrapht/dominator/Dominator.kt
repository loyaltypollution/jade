package org.ucombinator.jade.jgrapht.dominator

import org.jgrapht.Graph
import org.jgrapht.alg.lca.EulerTourRMQLCAFinder
import org.jgrapht.graph.SimpleDirectedGraph
import org.ucombinator.jade.util.Errors

class TotalMutableMap<K, V>(): HashMap<K, V>() { // TODO: rename? NonnullMutableMap NotMissingMutableMap
  operator override fun get(key: K): V =
    if (this.containsKey(key)) super.get(key)!! else throw NoSuchElementException("Key $key is missing in the map.")
}
class DefaultZeroMutableMap<K, V>(): HashMap<K, V?>() { // TODO: rename? OrZeroMutableMap
  operator override fun get(key: K): V =
    if (this.containsKey(key)) super.get(key)!! else throw NoSuchElementException("Key $key is missing in the map.")
  fun getOrNull(key: K): V? = super.get(key)
  fun getOrZero(key: K, action: (V) -> Int): Int = super.get(key).let { if (it == null) 0 else action(it) }
}

fun <A> A?.orZero(action: (A) -> Int): Int = if (this == null) 0 else action(this)

typealias DominatorTree<V> = Graph<V, Dominator.Edge<V>>

/** TODO:doc.
 *
 * @param V TODO:doc
 * @property tree TODO:doc
 * @property root TODO:doc
 */
data class Dominator<V>(val tree: Graph<V, Dominator.Edge<V>>, val root: V) {
  private val lca = EulerTourRMQLCAFinder(tree, root)

  /** TODO:doc.
   *
   * @param a TODO:doc
   * @param b TODO:doc
   * @return TODO:doc
   */
  fun dominates(a: V, b: V): Boolean = lca.getLCA(a, b) == a

  /** TODO:doc.
   *
   * @param a TODO:doc
   * @param b TODO:doc
   * @return TODO:doc
   */
  fun dominatesSource(a: V, b: Dominator.Edge<V>): Boolean = lca.getLCA(a, tree.getEdgeSource(b)) == a

  /** TODO:doc.
   *
   * @param a TODO:doc
   * @param b TODO:doc
   * @return TODO:doc
   */
  fun dominatesTarget(a: V, b: Dominator.Edge<V>): Boolean = lca.getLCA(a, tree.getEdgeSource(b)) == a

  /** TODO:doc.
   *
   * @param V TODO:doc
   * @property source TODO:doc
   * @property target TODO:doc
   */
  data class Edge<V>(val source: V, val target: V)

  companion object {
    /** TODO:doc.
     *
     * @param V TODO:doc
     * @param E TODO:doc
     * @param tree TODO:doc
     * @param v1 TODO:doc
     * @param v2 TODO:doc
     * @return TODO:doc
     */
    fun <V, E> isDominator(tree: Graph<V, E>, v1: V, v2: V): Boolean =
      if (v1 == v2) {
        true
      } else {
        val edges = tree.outgoingEdgesOf(v2)
        when (val size = edges.size) {
          0 -> false
          1 -> isDominator(tree, v1, tree.getEdgeTarget(edges.first()))
          else -> Errors.unmatchedValue(size)
        }
      }

    /** TODO:doc.
     *
     * This implements the algorithm in the paper:
     *   THOMAS LENGAUER and ROBERT ENDRE TARJAN. A Fast Algorithm for Finding Dominators in a Flowgraph.
     *   ACM Transactions on Programming Languages and Systems, Vol. 1, No. 1, July 1979, Pages 121-141.
     *
     * @param V TODO:doc
     * @param E TODO:doc
     * @param graph TODO:doc
     * @param start TODO:doc
     * @return TODO:doc
     */

    // Input
    // succ(v): The set of vertices w such that (v, w) is an edge of the graph.
    // Computed
    // parent(w): The vertex which is the parent of vertex w in the spanning tree generated by the search.
    // pred(w): The set of vertices v such that (v, w) is an edge of the graph.
    // semi(w): A number defmed as follows:
    //   (i) Before vertex w is numbered, semi(v) = O.
    //   (ii) After w is numbered but before its semidominator is computed, semi(w) is the
    //   number of w.
    //   (iii) After the semidominator of w is computed, semi(w) is the number of the semidom-
    //   inator of w.
    // vertex(i): The vertex whose number is i.
    // bucket(w): A set of vertices whose semidominator is w.
    // dom(w): A vertex defined as follows:
    //   (i) After step 3, if the semidominator of w is its immediate dominator, then dom(w) is
    //   the immediate dominator of w. Otherwise dom(w) is a vertex v whose number is
    //   smaller than w and whose immediate dominator is also w's immediate dominator.
    //   (ii) After step 4, dom(w) is the immediate dominator of w.

    // Use non-existing value/null for 0 in the paper
    // The original algorithm dealt in Ints, not Vs.

    fun <V, E> dominatorTree(graph: Graph<V, E>, root: V): DominatorTree<V> {
      // TODO: require(root in graph)
      val dom = TotalMutableMap<V, V>() // The idom (once known)

      val pred = TotalMutableMap<V, MutableSet<V>>() // predecessors but only if they are reachable
      // Use non-existing value/null for 0 in the paper
      val vertex = TotalMutableMap<Int, V>() /*DFNum->V:1..n*/ // The vertex assigned to a given number by dfs (inverse of semi)
      val semi = TotalMutableMap<V, Int>() /*V->DFNum:0..n*/ // The semidominator of each V
        // 0 = not visited by dfs
        // sdom?
        // The order of nodes reached in DFS.
      val parent = TotalMutableMap<V, V>() // ->V?? The parent of node in DFS tree

      val ancestor = TotalMutableMap<V, V>() // ->V? Used by ancestorWithLowestSemi. (compress?)
        // Mutable and path compressed.
        // 0 means no ancestor?
      val label = TotalMutableMap<V, V>() // V?->V? but only for 0? // 0 is actually used // // The ancestor of V with lowest semidominator?
      val bucket = TotalMutableMap<V, MutableSet<V>>() // (n + 1) { mutableSetOf() } /*1..n*/ // A set of vertices whose semidominator is w // buckets of nodes with the same sdom

      val size = TotalMutableMap<V, Int>() /*0..n*/ // used only by sophisticated link
      val child = DefaultZeroMutableMap<V, V>() /*V:1..n*/ // used only by sophisticated link

      // Step 1: Setup.  Carry out a depth-first search of the problem graph. Number the vertices from 1 to n as they are reached
      // during the search.  Initialize the variables used in succeeding steps.

      // vertex numbers are 1 (not 0) based to match the paper's algorithm

      var n = 0
      fun dfs(v: V) { // TODO: recursion depth limit? so convert to stack (but remember to reverse pushed elements)?
        n += 1
        semi[v] = n
        vertex[n] = v
        label[v] = v
        size[v] = 1
        bucket[v] = mutableSetOf() // Not in original algorithm, but added to initialize bucket
        pred[v] = mutableSetOf() // Not in original algorithm, but added to initialize label
        for (w in graph.outgoingEdgesOf(v).map(graph::getEdgeTarget)) { // only time outgoingEdgesOf() is called
          if (!semi.contains(w)) { parent[w] = v; dfs(w) } // for vertexes not yet visited by DFS
          pred[w] += v
        }
      }
      dfs(root)

      fun compress(v: V) { // used only in eval()
        if (ancestor.contains(ancestor[v])) {
          compress(ancestor[v])
          if (semi[label[ancestor[v]]] < semi[label[v]]) { label[v] = label[ancestor[v]] }
          ancestor[v] = ancestor[ancestor[v]] // ancestor initially means parent; only modified here
        }
      }

      // Finds the ancestor of v with the lowest semidominator. Uses path compression to keep runtime down.

      // "simple" implementation of link and eval instead of the "sophisticated" implementation
      fun evalSimple(v: V): V = if (!ancestor.contains(v)) { v } else { compress(v); label[v] }
      fun evalSophisticated(v: V): V =
        if (!ancestor.contains(v)) { label[v] }
        else {
          compress(v)
          if (semi[label[ancestor[v]]] >= semi[label[v]]) { label[v] } else { label[ancestor[v]] }
        }

      // make v the parent(ancestor?) of w
      fun linkSimple(v: V, w: V) { ancestor[w] = v }
      fun linkSophisticated(v: V, w: V) {
        var s: V = w
        // if we fix this does semi need 0?
        // TODO: use getOrZero
        while (semi[label[w]] < child.getOrZero(s) { semi[label[it]] }) {
          if (size[s] + child.getOrZero(child[s]) { size[it] } >= 2 * size[child[s]]) {
            ancestor[child[s]] = s
            child[s] = child.getOrNull(child[s])
          } else {
            size[child[s]!!] = size[s]
            ancestor[s] = child[s]
            s = child[s]!!
          }
        }
        label[s] = label[w]
        size[v] = size[v] + size[w]
        var sn: V? = s
        if (size[v] < 2 * size[w]) { sn = child.getOrNull(v).also { child[v] = sn } }
        while (sn != null) { ancestor[sn] = v; sn = child.getOrNull(sn) }
      }

      // fun eval(v: Int) = evalSimple(v)
      // fun link(v: Int, w: Int) = linkSimple(v, w)
      fun eval(v: V) = evalSophisticated(v)
      fun link(v: V, w: V) = linkSophisticated(v, w)

      // Iterate over nodes from bottom of DFS tree to top.
      for (i in n downTo 2) { // Exclude 1 because that is the root and never has a dominator
        val w = vertex[i] // get vertex at dfnum

        // step 2
        // Find the semidominator of v
        // Step 2: Compute the semidominators of all vertices by applying Theorem 4. Carry out the computation vertex by
        // vertex in decreasing order by number.
        for (v in pred[w]) { // graph.incomingEdgesOf(w).map(graph::getEdgeSource)) { // only call to pred
          val u = eval(v)
          // Determine if pred is an ancestor in DFS tree.
          if (semi[u] < semi[w]) { semi[w] = semi[u] }
        }
        bucket[vertex[semi[w]]] += w
        link(parent[w], w)

        // step 3
        // For each bucket, find ancestor with lowest semi. If it has the same
        // semi, that semi is the idom. If not, it has the same semidominator.
        // Step 3: Implicitly define the immediate dominator of each vertex by applying Corollary 1 from the paper.
        for (v in bucket[parent[w]]) {
          val u = eval(v)
          dom[v] = if (semi[u] < semi[v]) { u } else { parent[w] }
        }
        bucket[parent[w]].clear() // After the loop to avoid concurrent modification exception
      }

      // Step 4: Explicitly define the immediate dominator of each vertex, carrying out the
      // computation vertex by vertex in increasing order by DFNum.
      for (i in 2..n) { // Do not include 1 because that is the root and never has a dominator.
        val w = vertex[i]
        if (dom[w] != vertex[semi[w]]) { dom[w] = dom[dom[w]] }
      }

      // Lengauer-Tarjan algorithm complete.  Translate to the expected result format.
      val tree = SimpleDirectedGraph<V, Dominator.Edge<V>>(Dominator.Edge::class.java as Class<Dominator.Edge<V>>)
      for (v in graph.vertexSet()) { tree.addVertex(v) }
      for ((i, d) in dom) { tree.addEdge(i, d, Dominator.Edge<V>(i, d)) }

      return tree
    }
  }
}
